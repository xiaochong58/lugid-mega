"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var css_1 = require("@lugia/css");
var dict_1 = require("@lugia/dict");
exports.existDict = dict_1.existDict;
exports.getDict = dict_1.getDict;
var px2Number = css_1.units.px2Number;
var allBorderDirections = ['l', 't', 'r', 'b'];
var borderDirectionMap = {
    l: 'left',
    r: 'right',
    t: 'top',
    b: 'bottom',
};
function getDictValue(value) {
    if (!value || typeof value !== 'string') {
        return value;
    }
    if (value.startsWith('$lugia-dict')) {
        var dictConfig = value.split('.');
        if (dictConfig.length >= 3) {
            var dictName = dictConfig[1];
            var keyValue = dictConfig.slice(2).join('.');
            if (!dict_1.existDict(dictName)) {
                return undefined;
            }
            var dict = dict_1.getDict(dictName);
            return dict.get(keyValue);
        }
    }
    return value;
}
exports.getDictValue = getDictValue;
function getBorder(border, opt) {
    if (opt === void 0) { opt = { directions: allBorderDirections }; }
    var _a = opt.directions, directions = _a === void 0 ? allBorderDirections : _a;
    if (!directions || directions.length === 0) {
        return {};
    }
    var result = {};
    var theBorder = getDictValue(border);
    return directions.reduce(function (outResult, direction) {
        var directionWord = borderDirectionMap[direction];
        if (outResult[directionWord]) {
            return outResult;
        }
        var color = theBorder.color, style = theBorder.style, width = theBorder.width;
        var borderConfig = {};
        if ('color' in theBorder) {
            borderConfig.color = getDictValue(color);
        }
        if ('style' in theBorder) {
            borderConfig.style = style;
        }
        if ('width' in theBorder) {
            borderConfig.width = width;
        }
        outResult[directionWord] = borderConfig;
        return outResult;
    }, result);
}
exports.getBorder = getBorder;
var allBorderRadiusDirections = [
    'tl',
    'tr',
    'bl',
    'br',
];
var borderRadiusDirectionMap = {
    tl: 'topLeft',
    tr: 'topRight',
    bl: 'bottomLeft',
    br: 'bottomRight',
};
function getBorderRadius(radius, directions) {
    if (directions === void 0) { directions = allBorderRadiusDirections; }
    var theRadius = getDictValue(radius);
    return directions.reduce(function (result, direction) {
        var targetKey = borderRadiusDirectionMap[direction];
        result[targetKey] = theRadius;
        return result;
    }, {});
}
exports.getBorderRadius = getBorderRadius;
function getBoxShadow(shadowStr) {
    if (!shadowStr) {
        return {};
    }
    var shadow = getDictValue(shadowStr);
    var rgbIndex = shadow.toUpperCase().indexOf('RGB');
    var color = '';
    if (rgbIndex !== -1) {
        color = shadow.substr(rgbIndex);
        shadow = shadow.substr(0, rgbIndex);
    }
    var config = shadow.split(' ').filter(function (str) { return str !== ''; });
    var type = 'outset';
    if (config[0].toUpperCase() === 'INSET') {
        type = 'inset';
        config.splice(0, 1);
    }
    var x = config[0], y = config[1], blur = config[2], spread = config[3];
    if (!color && config.length > 2) {
        color = config[config.length - 1];
    }
    var vX = px2Number(x);
    var vY = px2Number(y);
    if (isNaN(vX) || isNaN(vY)) {
        return {
            x: 0,
            y: 0,
            blur: 0,
            spread: 0,
            color: '',
            type: '',
        };
    }
    return {
        x: px2Number(x) || 0,
        y: px2Number(y) || 0,
        blur: px2Number(blur) || 0,
        spread: px2Number(spread) || 0,
        color: color,
        type: type,
    };
}
exports.getBoxShadow = getBoxShadow;
function getBoxShadowCSS(boxConfig) {
    if (typeof boxConfig === 'string') {
        if (boxConfig === 'none') {
            return 'none';
        }
    }
    var x = boxConfig.x, y = boxConfig.y, _a = boxConfig.blur, blur = _a === void 0 ? 0 : _a, _b = boxConfig.spread, spread = _b === void 0 ? 0 : _b, _c = boxConfig.color, color = _c === void 0 ? '' : _c;
    var _d = boxConfig.type, type = _d === void 0 ? 'outset' : _d;
    if (type !== 'inset') {
        type = '';
    }
    return (type + " " + x + "px " + y + "px " + blur + "px " + spread + "px " + color).trim();
}
exports.getBoxShadowCSS = getBoxShadowCSS;
//# sourceMappingURL=index.js.map