"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var colorTable_1 = tslib_1.__importDefault(require("./colorTable"));
var hexColorRegExp = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
var regWord = /^[a-zA-Z]*$/;
function colorIsWord(sHex) {
    var newHex = sHex.toLowerCase();
    var item = colorTable_1.default.find(function (_a) {
        var englishName = _a.englishName;
        return newHex === englishName.toLowerCase();
    });
    return {
        hex: item ? item.Hex : undefined,
        state: !!item,
    };
}
function colorRgb(sHex) {
    var hexColor = sHex;
    var isWord = regWord.test(sHex);
    if (sHex && isWord) {
        var _a = colorIsWord(sHex), hex = _a.hex, state = _a.state;
        if (!state) {
            return [255, 255, 255];
        }
        hexColor = hex || '';
    }
    var sColor = hexColor && hexColor.toLowerCase();
    // 如果是16进制颜色
    if (sColor && hexColorRegExp.test(sColor)) {
        if (sColor.length === 4) {
            var sColorNew = '#';
            for (var i = 1; i < 4; i += 1) {
                var colorSlice = sColor.slice(i, i + 1);
                sColorNew += colorSlice.concat(colorSlice);
            }
            sColor = sColorNew;
        }
        // 处理六位的颜色值
        var sColorChange = [];
        for (var i = 1; i <= 6; i += 2) {
            sColorChange.push(parseInt('0x' + sColor.slice(i, i + 2), 16));
        }
        return sColorChange;
        // return "RGB(" + sColorChange.join(",") + ")";
    }
    return [255, 255, 255];
}
exports.colorRgb = colorRgb;
function rgb2hsb(rgbR, rgbG, rgbB, reduceS, reduceB) {
    if (rgbR === void 0) { rgbR = 0; }
    if (rgbG === void 0) { rgbG = 0; }
    if (rgbB === void 0) { rgbB = 0; }
    if (reduceS === void 0) { reduceS = 0; }
    if (reduceB === void 0) { reduceB = 0; }
    var max = Math.max(rgbR, rgbG, rgbB);
    var min = Math.min(rgbR, rgbG, rgbB);
    var hsbB = max / 255.0 - reduceB;
    var hsbS = (max === 0 ? 0 : (max - min) / max) - reduceS;
    var hsbH = 0;
    var molecular = (rgbG - rgbB) * 60;
    var denominator = max - min; // 分母不能为0
    var publicFormula = denominator === 0 ? 0 : molecular / denominator;
    if (max === rgbR) {
        hsbH = rgbG >= rgbB ? publicFormula : publicFormula + 360;
    }
    else if (max === rgbG) {
        hsbH = ((rgbB - rgbR) * 60) / (max - min) + 120;
    }
    else if (max === rgbB) {
        hsbH = ((rgbR - rgbG) * 60) / (max - min) + 240;
    }
    return [hsbH, hsbS, hsbB];
}
exports.rgb2hsb = rgb2hsb;
function hsb2rgb(h, s, v) {
    var red = 0;
    var green = 0;
    var blue = 0;
    var i = parseInt(String((h / 60) % 6), 10);
    var f = h / 60 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    switch (i) {
        case 0:
            red = v;
            green = t;
            blue = p;
            break;
        case 1:
            red = q;
            green = v;
            blue = p;
            break;
        case 2:
            red = p;
            green = v;
            blue = t;
            break;
        case 3:
            red = p;
            green = q;
            blue = v;
            break;
        case 4:
            red = t;
            green = p;
            blue = v;
            break;
        case 5:
            red = v;
            green = p;
            blue = q;
            break;
        default:
            break;
    }
    red = Math.round(red * 255);
    green = Math.round(green * 255);
    blue = Math.round(blue * 255);
    return { newR: red, newG: green, newB: blue };
}
exports.hsb2rgb = hsb2rgb;
function colorHex(rgb) {
    // 如果是rgb颜色表示
    if (/^(rgb|RGB)/.test(rgb)) {
        var aColor = rgb.replace(/(?:\(|\)|rgb|RGB)*/g, '').split(',');
        var strHex = '#';
        for (var _i = 0, aColor_1 = aColor; _i < aColor_1.length; _i++) {
            var color = aColor_1[_i];
            var hex = Number(color).toString(16);
            if (hex.length < 2) {
                hex = '0' + hex;
            }
            strHex += hex;
        }
        if (strHex.length !== 7) {
            strHex = rgb;
        }
        return strHex;
    }
    else if (hexColorRegExp.test(rgb)) {
        var aNum = rgb.replace(/#/, '').split('');
        if (aNum.length === 6) {
            return rgb;
        }
        else if (aNum.length === 3) {
            var numHex = '#';
            for (var _a = 0, aNum_1 = aNum; _a < aNum_1.length; _a++) {
                var num = aNum_1[_a];
                numHex += num + num;
            }
            return numHex;
        }
    }
    return rgb;
}
exports.colorHex = colorHex;
function getColor(sHex, reduceS, reduceB, reduceA) {
    if (sHex === void 0) { sHex = '#684fff'; }
    if (reduceS === void 0) { reduceS = 0; }
    if (reduceB === void 0) { reduceB = 0; }
    if (reduceA === void 0) { reduceA = 100; }
    reduceS /= 100;
    reduceB /= 100;
    reduceA /= 100;
    var _a = hsb2rgb.apply(void 0, rgb2hsb.apply(void 0, tslib_1.__spreadArrays(colorRgb(sHex), [reduceS, reduceB]))), newR = _a.newR, newG = _a.newG, newB = _a.newB;
    var rgb = "rgb(" + newR + "," + newG + "," + newB + ")";
    var color = colorHex(rgb);
    var rgba = "rgba(" + newR + "," + newG + "," + newB + "," + reduceA + ")";
    return {
        color: color,
        opacity: reduceA,
        rgb: rgb,
        rgba: rgba,
    };
}
exports.default = getColor;
//# sourceMappingURL=utilsColor.js.map