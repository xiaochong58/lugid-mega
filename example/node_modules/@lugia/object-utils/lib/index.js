"use strict";
/**
 *
 * create by liangguodong on 2018/8/24
 *
 * @flow
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
var is_plain_object_1 = tslib_1.__importDefault(require("is-plain-object"));
function getAttributeFromObject(object, attribute, defaultValue) {
    return object && object[attribute] !== undefined
        ? object[attribute]
        : defaultValue;
}
exports.getAttributeFromObject = getAttributeFromObject;
function getKeyfromIndex(data, index, expKey) {
    var newKey = '';
    data.forEach(function (item, i) {
        if (i === index) {
            newKey =
                item[expKey] !== null && item[expKey] !== undefined
                    ? item[expKey]
                    : '_key_' + i;
        }
    });
    return newKey;
}
exports.getKeyfromIndex = getKeyfromIndex;
function getIndexfromKey(data, keyName, keyValue) {
    return data.findIndex(function (v) { return v[keyName] === keyValue; });
}
exports.getIndexfromKey = getIndexfromKey;
var overwriteMerge = function (destinationArray, sourceArray) {
    return sourceArray;
};
function deepMerge() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    return deepMergeOption(tslib_1.__spreadArrays(objects), { arrayMerge: overwriteMerge });
}
exports.deepMerge = deepMerge;
function deepMergeOption(objects, option) {
    if (option === void 0) { option = {}; }
    if (!objects || objects.length === 0) {
        return {};
    }
    var _a = option.arrayMerge, arrayMerge = _a === void 0 ? overwriteMerge : _a;
    return objects.reduce(function (pre, next) {
        next = next || {};
        return deepmerge_1.default(pre, next, { arrayMerge: arrayMerge });
    }, {});
}
exports.deepMergeOption = deepMergeOption;
function deepMergeForArrayMerge() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    if (!objects || objects.length === 0) {
        return {};
    }
    return objects.reduce(function (pre, next) {
        next = next || {};
        return deepmerge_1.default(pre, next);
    }, {});
}
exports.deepMergeForArrayMerge = deepMergeForArrayMerge;
function moveToTargetIfKeyIsInSource(key, source, target) {
    if (key in source) {
        target[key] = source[key];
        delete source[key];
    }
}
exports.moveToTargetIfKeyIsInSource = moveToTargetIfKeyIsInSource;
function deepMergeAnB(objectA, objectB, opt) {
    var beforeNames = opt.beforeNames;
    if (!objectA && !objectB) {
        return {};
    }
    objectA = deepMerge({}, objectA) || {};
    objectB = deepMerge({}, objectB) || {};
    var beforeResultA = {};
    var beforeResultB = {};
    beforeNames &&
        beforeNames.forEach(function (key) {
            moveToTargetIfKeyIsInSource(key, objectA, beforeResultA);
            moveToTargetIfKeyIsInSource(key, objectB, beforeResultB);
        });
    var beforeResult = deepMerge(beforeResultA, beforeResultB);
    var target = {};
    beforeNames &&
        beforeNames.forEach(function (key) {
            moveToTargetIfKeyIsInSource(key, beforeResult, target);
        });
    return deepMerge(target, objectA, objectB);
}
exports.deepMergeAnB = deepMergeAnB;
function isEmptyObject(obj) {
    if (obj === null || obj === undefined) {
        return true;
    }
    if (typeof obj !== 'object') {
        return true;
    }
    return Object.keys(obj).length === 0;
}
exports.isEmptyObject = isEmptyObject;
function getAttributeValue(obj, path) {
    if (!obj) {
        return;
    }
    if (!path || path.length === 0) {
        return;
    }
    var target = obj;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var key = path_1[_i];
        target = target[key];
        if (target === 0) {
            return target;
        }
        if (!target) {
            return;
        }
    }
    return target;
}
exports.getAttributeValue = getAttributeValue;
function setAttributeValue(outResult, paths, val) {
    if (!outResult) {
        return;
    }
    if (!paths || paths.length === 0) {
        return;
    }
    var length = paths.length;
    if (length === 0) {
        return;
    }
    var fatherKey = paths[0];
    if (length === 1) {
        outResult[fatherKey] = val;
        return;
    }
    var obj = outResult[fatherKey];
    var father = is_plain_object_1.default(obj) ? obj || {} : {};
    outResult[fatherKey] = father;
    for (var i = 1; i < length - 1; i++) {
        var thePath = paths[i];
        var theFather = father[thePath];
        if (!theFather) {
            theFather = father[thePath] = {};
        }
        if (!is_plain_object_1.default(father[thePath])) {
            father[thePath] = {};
        }
        father = father[thePath];
    }
    var valKey = paths[length - 1];
    father[valKey] = val;
}
exports.setAttributeValue = setAttributeValue;
function packPathObject(object) {
    var keys = Object.keys(object).sort(function (a, b) { return a.length - b.length; });
    var outResult = {};
    keys.forEach(function (key) {
        var paths = key.split('.');
        var item = object[key];
        setAttributeValue(outResult, paths, item);
    });
    return outResult;
}
exports.packPathObject = packPathObject;
function packObject(path, value) {
    if (!path || path.length === 0) {
        return {};
    }
    var result = {};
    var current = result;
    var lastIndex = path.length - 1;
    path.forEach(function (key, index) {
        if (lastIndex === index) {
            current[key] = value;
        }
        else {
            current = current[key] = {};
        }
    });
    return result;
}
exports.packObject = packObject;
function object2pathObject(obj) {
    return object2pathObjectHelper(obj, '');
}
exports.object2pathObject = object2pathObject;
function object2pathObjectHelper(obj, father) {
    if (!is_plain_object_1.default(obj)) {
        return obj;
    }
    var res = {};
    Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        var targetKey = father ? father + "." + key : key;
        if (!is_plain_object_1.default(val)) {
            res[targetKey] = val;
        }
        else {
            res = tslib_1.__assign(tslib_1.__assign({}, res), object2pathObjectHelper(val, targetKey));
        }
    });
    return res;
}
function diffABWhenAttrIfExist(objA, objB) {
    var res = [];
    if (!objA || !objB) {
        return res;
    }
    var pathObjectsA = object2pathObject(objA);
    var pathObjectsB = object2pathObject(objB);
    var pathsA = Object.keys(pathObjectsA);
    var pathsB = Object.keys(pathObjectsB);
    var minPath = pathsA.length > pathsB.length ? pathsA : pathsB;
    function isNotEqualSimple(key) {
        var path = key.split('.');
        var valA = pathObjectsA[key] || getAttributeValue(objA, path);
        var valB = pathObjectsB[key] || getAttributeValue(objB, path);
        return valA !== undefined && valB !== undefined && valA !== valB;
    }
    var resObj = {};
    minPath.forEach(function (key) {
        if (isNotEqualSimple(key)) {
            resObj[key] = true;
        }
    });
    return Object.keys(resObj);
}
exports.diffABWhenAttrIfExist = diffABWhenAttrIfExist;
//# sourceMappingURL=index.js.map